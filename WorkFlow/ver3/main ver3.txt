#include <SFML/Graphics.hpp>
#include <SFML/Audio.hpp>
#include <optional>
#include <cstdint>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include<random>
// ----------------- 资源管理单例 -----------------
struct ResourceManager {
    std::unordered_map<std::string, sf::Texture>    textures;
    std::unordered_map<std::string, sf::SoundBuffer> soundBuffers;
    std::unordered_map<std::string, sf::Font>       fonts;

    static ResourceManager& getInstance() { static ResourceManager r; return r; }

    ResourceManager()
    {
        // 贴图
        textures["Brick"].loadFromFile("assets/images/BrickPicture.png");
        textures["Paddle"].loadFromFile("assets/images/PaddlePicture.png");
        textures["Ball"].loadFromFile("assets/images/SmallBallPicture.png");
        textures["Bg1"].loadFromFile("assets/images/Level1GameBackground.png");
        textures["Bg2"].loadFromFile("assets/images/Level2GameBackground.png");
        textures["Bg3"].loadFromFile("assets/images/Level3GameBackground.png");
        // 音效
        soundBuffers["Impact"].loadFromFile("assets/sounds/ImpactSound.wav");
        soundBuffers["Rebound"].loadFromFile("assets/sounds/ReboundSound.wav");
        soundBuffers["BGM"].loadFromFile("assets/sounds/BackgroundMusic.wav");
        // 字体
        fonts["Arial"].openFromFile("assets/fonts/arial.ttf");
        fonts["Consola"].openFromFile("assets/fonts/consola.ttf");
    }

    sf::Texture& getTexture(const std::string& key) { return textures.at(key); }
    sf::SoundBuffer& getSoundBuffer(const std::string& k) { return soundBuffers.at(k); }
    sf::Font& getFont(const std::string& key) { return fonts.at(key); }
};

// ----------------- 音效管理类 -----------------
class SoundManager {
    sf::Sound impactSound;
    sf::Sound reboundSound;
    sf::Music music;
    bool enableSound = true, enableMusic = true;

public:
    SoundManager()
        : impactSound(ResourceManager::getInstance().getSoundBuffer("Impact"))
        , reboundSound(ResourceManager::getInstance().getSoundBuffer("Rebound"))
    {
        // 背景音乐用 sf::Music
        if (music.openFromFile("assets/sounds/BackgroundMusic.wav")) {
            music.setLooping(true);
        }
    }

    void playImpact() { if (enableSound) impactSound.play(); }
    void playRebound() { if (enableSound) reboundSound.play(); }
    void playMusic() { if (enableMusic && music.getStatus() != sf::Music::Status::Playing) music.play(); }
    void stopMusic() { music.stop(); }
    void setSound(bool e) { enableSound = e; }
    void setMusic(bool e) { enableMusic = e; }
    bool isSoundOn() const { return enableSound; }
    bool isMusicOn() const { return enableMusic; }
};

// ----------------- 存档管理类 -----------------
struct SaveData {
    int level = 1;
    float paddleX = 0;
    float ballX = 0, ballY = 0;
    float ballVelX = 0, ballVelY = 0;
    std::vector<uint8_t> bricksAlive; // 0 = 死，1 = 存在
    void save(const std::string& path) {
        std::ofstream out(path, std::ios::binary);
        out.write((char*)&level, sizeof(level));          // 写入关卡
        out.write((char*)&paddleX, sizeof(paddleX));
        out.write((char*)&ballX, sizeof(ballX));
        out.write((char*)&ballY, sizeof(ballY));
        out.write((char*)&ballVelX, sizeof(ballVelX));
        out.write((char*)&ballVelY, sizeof(ballVelY));
        uint32_t n = bricksAlive.size();
        out.write((char*)&n, sizeof(n));
        out.write((char*)bricksAlive.data(), n);
    }
    bool load(const std::string& path) {
        std::ifstream in(path, std::ios::binary);
        if (!in) return false;
        in.read((char*)&level, sizeof(level));            // 读出关卡
        in.read((char*)&paddleX, sizeof(paddleX));
        in.read((char*)&ballX, sizeof(ballX));
        in.read((char*)&ballY, sizeof(ballY));
        in.read((char*)&ballVelX, sizeof(ballVelX));
        in.read((char*)&ballVelY, sizeof(ballVelY));
        uint32_t n = 0;
        in.read((char*)&n, sizeof(n));
        bricksAlive.resize(n);
        in.read((char*)bricksAlive.data(), n);
        return true;
    }
};

// ------------- 主菜单界面 ---------------
class MenuScene {
    sf::Text title;
    sf::Text start;
    sf::Text help;
    sf::Text quit;
    int selected;
public:
    MenuScene()
        : title(ResourceManager::getInstance().getFont("Arial"), "Breakout 3.0", 64)
        , start(ResourceManager::getInstance().getFont("Arial"), "Start Game", 48)
        , help(ResourceManager::getInstance().getFont("Arial"), "Help", 48)
        , quit(ResourceManager::getInstance().getFont("Arial"), "Quit", 48)
        , selected(0)
    {
        title.setFillColor(sf::Color::Yellow);
        start.setFillColor(sf::Color::White);
        help.setFillColor(sf::Color::White);
        quit.setFillColor(sf::Color::White);
        float cx = 800 / 2.0f;
        title.setOrigin({ title.getLocalBounds().size.x / 2.0f, title.getLocalBounds().size.y / 2.0f });
        title.setPosition({ cx,100 });
        start.setPosition({ cx - 100, 270 });
        help.setPosition({ cx - 100, 350 });
        quit.setPosition({ cx - 100, 430 });
    }

    // 0-开始 1-帮助 2-退出, 无操作-返回-1
    int run(sf::RenderWindow& window, SoundManager& sound) {
        selected = 0;
        while (window.isOpen()) {
            window.clear();
            window.draw(title);
            start.setFillColor(selected == 0 ? sf::Color::Green : sf::Color::White);
            help.setFillColor(selected == 1 ? sf::Color::Green : sf::Color::White);
            quit.setFillColor(selected == 2 ? sf::Color::Green : sf::Color::White);
            window.draw(start); window.draw(help); window.draw(quit);
            window.display();

            while (const auto event = window.pollEvent()) {
                if (event->is<sf::Event::Closed>()) window.close();
                if (event->is<sf::Event::KeyPressed>()) {
                    auto key = event->getIf<sf::Event::KeyPressed>()->scancode;
                    using K = sf::Keyboard::Scancode;
                    if (key == K::Down) { if (++selected > 2) selected = 0; sound.playImpact(); }
                    else if (key == K::Up) { if (--selected < 0) selected = 2; sound.playImpact(); }
                    else if (key == K::Enter) { sound.playImpact(); return selected; }
                    else if (key == K::Escape) { return 2; }
                }
            }
        }
        return -1;
    }
};

// ------------- 启动（Logo）界面 ---------------
class SplashScene {
    sf::Text text;
    int timer = 0;
public:
    SplashScene()
        : text(ResourceManager::getInstance().getFont("Arial"), "Welcome to Breakout!", 40)
    {
        text.setFillColor(sf::Color::White);
        text.setOrigin({ text.getLocalBounds().size.x / 2.f, text.getLocalBounds().size.y / 2.f });
        text.setPosition({ 800.f / 2.f, 600.f / 2.f });
    }
    void run(sf::RenderWindow& window, SoundManager& sound) {
        sound.playMusic();
        int ticks = 60 * 2;
        while (window.isOpen() && ticks-- > 0) {
            while (window.pollEvent()) { /* only handle close */ }
            window.clear(sf::Color(30, 30, 40));
            window.draw(text);
            window.display();
            sf::sleep(sf::milliseconds(15));
        }
    }
};


// --------------- 帮助界面 ---------------
class HelpScene {
    std::vector<sf::Text> lines;
public:
    HelpScene() {
        auto& font = ResourceManager::getInstance().getFont("Arial");
        std::vector<std::string> h = {
            "Breakout v3",
            "Arrows : Move paddle",
            "Esc    : Back to menu",
            "S : Save, L : Load",
            "M : Toggle Music, N : Toggle Sound",
            "",
            "Press ESC to return"
        };
        for (size_t i = 0; i < h.size(); ++i) {
            sf::Text t(font, h[i], 36);
            t.setFillColor(sf::Color::White);
            t.setPosition({ 120, float(70 + 50 * i) });
            lines.push_back(t);
        }
    }
    void run(sf::RenderWindow& window) {
        while (window.isOpen()) {
            window.clear(sf::Color(0, 0, 30));
            for (auto& t : lines) window.draw(t);
            window.display();
            while (const auto event = window.pollEvent()) {
                if (event->is<sf::Event::Closed>()) window.close();
                if (event->is<sf::Event::KeyPressed>()) {
                    auto key = event->getIf<sf::Event::KeyPressed>()->scancode;
                    if (key == sf::Keyboard::Scancode::Escape) return;
                }
            }
        }
    }
};



// --------------- 主游戏界面 ---------------
class GameScene {
    static constexpr unsigned int WIDTH = 800, HEIGHT = 600;
    static constexpr float  PADDLE_HEIGHT = 20, PADDLE_SPEED = 8;
    static constexpr float BALL_RADIUS = 10, BALL_SPEED = 6;
    static constexpr int BRICK_COLS = 10, BRICK_ROWS = 5;
    static constexpr float BRICK_WIDTH = 75, BRICK_HEIGHT = 25, BRICK_GAP = 5;
    float paddleWidth;
    sf::Sprite background;
    int level;
    sf::RectangleShape paddle;
    sf::CircleShape ball;
    sf::Vector2f ballVelocity;
    std::vector<sf::RectangleShape> bricks;
    std::vector<bool> bricksAlive;
    bool isPlaying;
    sf::Text infoText;
    SoundManager& sound;
public:
    GameScene(SoundManager& sm, int lvl, std::optional<std::string> slotPath)
        : background(ResourceManager::getInstance().getTexture("Bg" + std::to_string(lvl)))
        , ball(BALL_RADIUS)
        , infoText(ResourceManager::getInstance().getFont("Arial"), "", 50)
        , sound(sm), level(lvl)
       
    {
        // background 位置/缩放
        background.setPosition({ 0,0 });
        // 如果背景大小 != 窗口，可按需缩放：
        // background.setScale(
        //   float(WIDTH)/background.getTexture()->getSize().x,
        //   float(HEIGHT)/background.getTexture()->getSize().y
        // );
        initLevel(level);
        if (slotPath) {
            SaveData d;
            if (d.load(*slotPath)) {
                // 已经在 initLevel 中填好了砖块和 paddleWidth
                // 还原位置
                paddle.setPosition({ d.paddleX, float(HEIGHT - PADDLE_HEIGHT - 20) });
                ball.setPosition({ d.ballX, d.ballY });
                ballVelocity = { d.ballVelX, d.ballVelY };
                for (size_t i = 0; i < bricksAlive.size(); ++i)
                    bricksAlive[i] = d.bricksAlive[i];
            }
        }
        resetPositions(); // 设置初始位置、速度、isPlaying=true
    }
    // 根据 level 初始化 paddleWidth、砖块布局
    void initLevel(int lvl) {
        // set paddleWidth
        switch (lvl) {
        case 1: paddleWidth = 150; break;
        case 2: paddleWidth = 100; break;
        case 3: paddleWidth = 60; break;
        default: paddleWidth = 100;
        }
        // paddle shape
        paddle = sf::RectangleShape({ paddleWidth, PADDLE_HEIGHT });
        paddle.setTexture(&ResourceManager::getInstance().getTexture("Paddle"));
        // 砖块布局
        bricks.clear();
        bricksAlive.clear();
        int rows = 5, cols = 10;
        float w = BRICK_WIDTH, h = BRICK_HEIGHT, gap = BRICK_GAP;
        std::vector<std::pair<float, float>> positions;
        if (level == 3) {
            // 随机 50 块
            std::mt19937 rng{ std::random_device{}() };
            std::uniform_real_distribution<float> dx(0, WIDTH - w), dy(50, 300);
            for (int i = 0; i < 50; ++i)
                positions.emplace_back(dx(rng), dy(rng));
        }
        else {
            for (int i = 0; i < rows; ++i)
                for (int j = 0; j < cols; ++j)
                    if (level != 1 || i == 0 || i == rows - 1 || j == 0 || j == cols - 1) // 第一关空心
                        positions.emplace_back(
                            j * (w + gap) + (WIDTH - (cols * (w + gap) - gap)) / 2.f,
                            i * (h + gap) + 50.f
                        );
        }
        for (auto& pos : positions) {
            sf::RectangleShape brick({ w,h });
            brick.setTexture(&ResourceManager::getInstance().getTexture("Brick"));
            brick.setPosition({ pos.first, pos.second });
            bricks.push_back(brick);
            bricksAlive.push_back(true);
        }
    }
    void resetPositions() {
        paddle.setPosition({ (WIDTH - paddleWidth) / 2, HEIGHT - PADDLE_HEIGHT - 20 });
        ball = sf::CircleShape(BALL_RADIUS);
        ball.setOrigin({ BALL_RADIUS, BALL_RADIUS });
        ball.setTexture(&ResourceManager::getInstance().getTexture("Ball"));
        ball.setPosition({ WIDTH / 2.f, HEIGHT / 2.f });
        ballVelocity = { BALL_SPEED, -BALL_SPEED };
        isPlaying = true;
        infoText.setString("");
    }

    // 新增：运行返回值
   // >0 -> 新开始的关卡号； 0 -> 返回主菜单
    int run(sf::RenderWindow& window) {
        sound.playMusic();
        // 主循环
        while (window.isOpen()) {
            // … 拷贝原 updateAndInput+render 逻辑 …
            if (!updateAndInput(window)) break;
        }
        if (!window.isOpen()) return 0;
        // 游戏结束后的选项提示
        infoText.setString("Press 1-3 to restart, ESC to menu");
        render(window);
        while (window.isOpen()) {
            while (const auto& e = window.pollEvent()) {
                if (e->is<sf::Event::Closed>()) window.close();
                if (e->is<sf::Event::KeyPressed>()) {
                    auto key = e->getIf<sf::Event::KeyPressed>()->scancode;
                    using K = sf::Keyboard::Scancode;
                    if (key == K::Escape) return 0;
                    if (key == K::Num1) return level;      // 重新本关
                    if (key == K::Num2) return level == 1 ? 2 : 1; // 简单示例：按2切下一关
                    if (key == K::Num3) return 1;          // 简单示例
                }
            }
            sf::sleep(sf::milliseconds(10));
        }
        return 0;
    }

    void render(sf::RenderWindow& window) {
        window.clear(sf::Color::Black);
        window.draw(background);     // <-- 新增
        window.draw(paddle);
        window.draw(ball);
        for (size_t i = 0; i < bricks.size(); ++i)
            if (bricksAlive[i]) window.draw(bricks[i]);
        
        if (!isPlaying) {
            // 居中
            sf::FloatRect textRect = infoText.getLocalBounds();
            infoText.setOrigin({ textRect.position.x + textRect.size.x / 2,
                                 textRect.position.y + textRect.size.y / 2 });
            infoText.setPosition({ WIDTH / 2.0f, HEIGHT / 2.0f });
            window.draw(infoText);
        }
        window.display();
    }

    bool handleEvent(const sf::Event& event, sf::RenderWindow& window) {
        if (event.is<sf::Event::Closed>()) window.close();
        if (event.is<sf::Event::KeyPressed>()) {
            auto key = event.getIf<sf::Event::KeyPressed>()->scancode;
            using K = sf::Keyboard::Scancode;
            if (key == K::Escape) return false;
            if (key == K::S) {
                // 简单菜单：1～3号存档
                infoText.setString("Save to slot 1-3");
                render(window);
                while (window.isOpen()) {
                    while (const auto& e = window.pollEvent()) {
                        if (e->is<sf::Event::KeyPressed>()) {
                            auto k2 = e->getIf<sf::Event::KeyPressed>()->scancode;
                            using K2 = sf::Keyboard::Scancode;
                            if (k2 >= K2::Num1 && k2 <= K2::Num3) {
                                int slot = int(k2) - int(K2::Num1) + 1;
                                save(std::string("assets/save/slot") + char('0' + slot) + ".sav");
                                sound.playImpact();
                                return true;
                            }
                            if (k2 == K2::Escape) return true;
                        }
                    }
                }
            }

            if (key == K::L) load("assets/save/slot.sav");
            if (key == K::M) { sound.setMusic(!sound.isMusicOn()); if (sound.isMusicOn()) sound.playMusic(); else sound.stopMusic(); }
            if (key == K::N) sound.setSound(!sound.isSoundOn());
        }
        return true;
    }

    // 游戏每帧主循环，如果游戏结束返回false，菜单ESC返回false
    bool updateAndInput(sf::RenderWindow& window) {
        if (!window.isOpen()) return false;
        while (const auto event = window.pollEvent()) {
            if (!handleEvent(*event, window)) return false;
        }
        if (isPlaying) {
            // 移动
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Left) && paddle.getPosition().x > 0)
                paddle.move({ -PADDLE_SPEED, 0 });
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Right) && paddle.getPosition().x + paddleWidth < WIDTH)
                paddle.move({ PADDLE_SPEED, 0 });
            ball.move(ballVelocity);
            // 墙壁
                // 墙壁反弹
            if (ball.getPosition().x - BALL_RADIUS < 0 || ball.getPosition().x + BALL_RADIUS > WIDTH) {
                ballVelocity.x = -ballVelocity.x;
                sound.playRebound();       // <-- 改为反弹音
            }
            // 上边界反弹
            if (ball.getPosition().y - BALL_RADIUS <= 0) {
                ball.setPosition({ ball.getPosition().x, BALL_RADIUS }); // 推回边界
                ballVelocity.y = std::abs(ballVelocity.y);
                sound.playRebound();
            }


            if (ball.getPosition().y - BALL_RADIUS > HEIGHT) {
                infoText.setString("Game Over!");
                isPlaying = false;
                sound.playImpact();
            }
            // 挡板反弹
            if (ball.getGlobalBounds().findIntersection(paddle.getGlobalBounds())) {
                ballVelocity.y = -std::abs(ballVelocity.y);
                ball.setPosition({ ball.getPosition().x, paddle.getPosition().y - BALL_RADIUS - 1 });
                sound.playRebound();
            }
            // 砖块撞击
            for (size_t i = 0; i < bricks.size(); ++i) {
                if (!bricksAlive[i]) continue;
                if (ball.getGlobalBounds().findIntersection(bricks[i].getGlobalBounds())) {
                    bricksAlive[i] = false;
                    ballVelocity.y = -ballVelocity.y;
                    sound.playImpact();     // <-- 播放撞砖块音
                    break;
                }
            }

            // 胜利
            bool empty = true;
            for (bool v : bricksAlive) if (v) empty = false;
            if (empty) {
                infoText.setString("You Win!");
                isPlaying = false;
                sound.playImpact();
            }
        }
        render(window);
        return true;
    }

    void save(const std::string& path) {
        SaveData d;
        d.paddleX = paddle.getPosition().x;
        d.ballX = ball.getPosition().x;
        d.ballY = ball.getPosition().y;
        d.ballVelX = ballVelocity.x;
        d.ballVelY = ballVelocity.y;
        d.bricksAlive.resize(bricksAlive.size());
        for (size_t i = 0; i < bricksAlive.size(); ++i) d.bricksAlive[i] = bricksAlive[i];
        d.save(path);
    }

    void load(const std::string& path) {
        SaveData d;
        if (!d.load(path)) return;
        paddle.setPosition({ d.paddleX, HEIGHT - PADDLE_HEIGHT - 20 });
        ball.setPosition({ d.ballX, d.ballY });
        ballVelocity = { d.ballVelX, d.ballVelY };
        for (size_t i = 0; i < bricksAlive.size() && i < d.bricksAlive.size(); ++i)
            bricksAlive[i] = d.bricksAlive[i];
        isPlaying = true;
        infoText.setString("");
    }
};

//开始菜单
// 返回值：1,2,3 = 新开始对应关卡；11,12,13 = 从 slot1～slot3 读取（并用存档里的 level）
int showStartMenu(sf::RenderWindow& window, SoundManager& sound) {
    const std::vector<std::string> opts = {
        "New Game: Level 1", "New Game: Level 2", "New Game: Level 3",
        "Load Slot1",       "Load Slot2",       "Load Slot3"
    };
    std::vector<sf::Text> texts;
    for (int i = 0; i < (int)opts.size(); ++i)
        texts.emplace_back(ResourceManager::getInstance().getFont("Arial"), opts[i], 36);
    int sel = 0;
    while (window.isOpen()) {
        window.clear(sf::Color(20, 20, 30));
        for (int i = 0; i < (int)texts.size(); ++i) {
            texts[i].setFillColor(i == sel ? sf::Color::Green : sf::Color::White);
            texts[i].setPosition({ 100.f, 100.f + 50.f * i });
            window.draw(texts[i]);
        }
        window.display();

        while (const auto e = window.pollEvent()) {
            if (e->is<sf::Event::Closed>()) window.close();
            if (e->is<sf::Event::KeyPressed>()) {
                auto key = e->getIf<sf::Event::KeyPressed>()->scancode;
                using K = sf::Keyboard::Scancode;
                if (key == K::Down) { sel = (sel + 1) % texts.size(); sound.playImpact(); }
                else if (key == K::Up) { sel = (sel - 1 + texts.size()) % texts.size(); sound.playImpact(); }
                else if (key == K::Enter) { sound.playImpact(); return sel < 3 ? (sel + 1) : (sel + 11); }
                else if (key == K::Escape) return 0;
            }
        }
    }
    return 0;
}


// ---------------------- 主流程 ----------------------
int main() {
    sf::RenderWindow window(sf::VideoMode({ 800,600 }), "Breakout3.0 (OOP/SFML3)");
    window.setFramerateLimit(60);
    try { ResourceManager::getInstance(); }
    catch (...) { return -1; }
    SoundManager sound;

    SplashScene splash;
    MenuScene menu;
    HelpScene help;

    while (window.isOpen()) {
        splash.run(window, sound);
        // 主菜单进入循环
        while (window.isOpen()) {
            int sel = menu.run(window, sound);
            if (sel == 0) { // Start Game
                // 首先让玩家选“新关卡”或“读取存档”
                int choice = showStartMenu(window, sound);
                if (choice == 0) continue; // ESC 或无效，回主菜单
                int  level = (choice <= 3 ? choice : 1);
                std::optional<std::string> slotPath;
                if (choice >= 11) {
                    int slot = choice - 10;
                    slotPath = std::string("assets/save/slot") + char('0' + slot) + ".sav";
                }
                // 循环“游戏-重开/换关-回菜单”
                int next = level;
                while (window.isOpen() && next > 0) {
                    GameScene game(sound, next, slotPath);
                    next = game.run(window);
                    slotPath.reset(); // 重开新关时不再 load
                }
            }

            else if (sel == 1) { // 帮助
                help.run(window);
            }
            else if (sel == 2) { // 退出
                window.close();
                break;
            }
        }
    }
    return 0;
}
