#include <SFML/Graphics.hpp>
#include <SFML/Audio.hpp>
#include <optional>
#include <cstdint>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>

// ----------------- 资源管理单例 -----------------
struct ResourceManager {
    sf::Texture texture;
    sf::SoundBuffer soundBuffer;
    sf::Font font;
    static ResourceManager& getInstance() { static ResourceManager r; return r; }
    ResourceManager() {
        texture.loadFromFile("assets/images/test.png");
        soundBuffer.loadFromFile("assets/sounds/test.wav");
        font.openFromFile("assets/fonts/arial.ttf");
    }
};

// ----------------- 音效管理类 -----------------
class SoundManager {
    sf::Sound sound;
    sf::Music music;
    bool enableSound = true, enableMusic = true;
public:
    SoundManager()
        : sound(ResourceManager::getInstance().soundBuffer) // 必须直接用 buffer 构造
    {
        if (music.openFromFile("assets/sounds/test.wav")) {
            music.setLooping(true); // sf3.0是setLooping，不是setLoop
        }
    }
    void playEffect() { if (enableSound) sound.play(); }
    void playMusic() { if (enableMusic && music.getStatus() != sf::Music::Status::Playing) music.play(); }
    void stopMusic() { music.stop(); }
    void setSound(bool e) { enableSound = e; }
    void setMusic(bool e) { enableMusic = e; }
    bool isSoundOn() const { return enableSound; }
    bool isMusicOn() const { return enableMusic; }
};

// ----------------- 存档管理类 -----------------
struct SaveData {
    float paddleX = 0;
    float ballX = 0, ballY = 0;
    float ballVelX = 0, ballVelY = 0;
    std::vector<uint8_t> bricksAlive; // 0 = 死，1 = 存在
    void save(const std::string& path) {
        std::ofstream out(path, std::ios::binary);
        out.write((char*)&paddleX, sizeof(paddleX));
        out.write((char*)&ballX, sizeof(ballX));
        out.write((char*)&ballY, sizeof(ballY));
        out.write((char*)&ballVelX, sizeof(ballVelX));
        out.write((char*)&ballVelY, sizeof(ballVelY));
        uint32_t n = bricksAlive.size();
        out.write((char*)&n, sizeof(n));
        out.write((char*)bricksAlive.data(), n);
    }
    bool load(const std::string& path) {
        std::ifstream in(path, std::ios::binary);
        if (!in) return false;
        in.read((char*)&paddleX, sizeof(paddleX));
        in.read((char*)&ballX, sizeof(ballX));
        in.read((char*)&ballY, sizeof(ballY));
        in.read((char*)&ballVelX, sizeof(ballVelX));
        in.read((char*)&ballVelY, sizeof(ballVelY));
        uint32_t n = 0;
        in.read((char*)&n, sizeof(n));
        bricksAlive.resize(n);
        in.read((char*)bricksAlive.data(), n);
        return true;
    }
};

// ------------- 主菜单界面 ---------------
class MenuScene {
    sf::Text title;
    sf::Text start;
    sf::Text help;
    sf::Text quit;
    int selected;
public:
    MenuScene()
        : title(ResourceManager::getInstance().font, "Breakout 3.0", 64)
        , start(ResourceManager::getInstance().font, "Start Game", 48)
        , help(ResourceManager::getInstance().font, "Help", 48)
        , quit(ResourceManager::getInstance().font, "Quit", 48)
        , selected(0)
    {
        title.setFillColor(sf::Color::Yellow);
        start.setFillColor(sf::Color::White);
        help.setFillColor(sf::Color::White);
        quit.setFillColor(sf::Color::White);
        float cx = 800 / 2.0f;
        title.setOrigin({ title.getLocalBounds().size.x / 2.0f, title.getLocalBounds().size.y / 2.0f });
        title.setPosition({ cx,100 });
        start.setPosition({ cx - 100, 270 });
        help.setPosition({ cx - 100, 350 });
        quit.setPosition({ cx - 100, 430 });
    }

    // 0-开始 1-帮助 2-退出, 无操作-返回-1
    int run(sf::RenderWindow& window, SoundManager& sound) {
        selected = 0;
        while (window.isOpen()) {
            window.clear();
            window.draw(title);
            start.setFillColor(selected == 0 ? sf::Color::Green : sf::Color::White);
            help.setFillColor(selected == 1 ? sf::Color::Green : sf::Color::White);
            quit.setFillColor(selected == 2 ? sf::Color::Green : sf::Color::White);
            window.draw(start); window.draw(help); window.draw(quit);
            window.display();

            while (const auto event = window.pollEvent()) {
                if (event->is<sf::Event::Closed>()) window.close();
                if (event->is<sf::Event::KeyPressed>()) {
                    auto key = event->getIf<sf::Event::KeyPressed>()->scancode;
                    using K = sf::Keyboard::Scancode;
                    if (key == K::Down) { if (++selected > 2) selected = 0; sound.playEffect(); }
                    else if (key == K::Up) { if (--selected < 0) selected = 2; sound.playEffect(); }
                    else if (key == K::Enter) { sound.playEffect(); return selected; }
                    else if (key == K::Escape) { return 2; }
                }
            }
        }
        return -1;
    }
};

// ------------- 启动（Logo）界面 ---------------
class SplashScene {
    sf::Text text;
    int timer = 0;
public:
    SplashScene()
        : text(ResourceManager::getInstance().font, "Welcome to Breakout!", 40)
    {
        text.setFillColor(sf::Color::White);
        text.setOrigin({ text.getLocalBounds().size.x / 2.f, text.getLocalBounds().size.y / 2.f });
        text.setPosition({ 800.f / 2.f, 600.f / 2.f });
    }
    void run(sf::RenderWindow& window, SoundManager& sound) {
        sound.playMusic();
        int ticks = 60 * 2;
        while (window.isOpen() && ticks-- > 0) {
            while (window.pollEvent()) { /* only handle close */ }
            window.clear(sf::Color(30, 30, 40));
            window.draw(text);
            window.display();
            sf::sleep(sf::milliseconds(15));
        }
    }
};


// --------------- 帮助界面 ---------------
class HelpScene {
    std::vector<sf::Text> lines;
public:
    HelpScene() {
        auto& font = ResourceManager::getInstance().font;
        std::vector<std::string> h = {
            "Breakout v3",
            "Arrows : Move paddle",
            "Esc    : Back to menu",
            "S : Save, L : Load",
            "M : Toggle Music, N : Toggle Sound",
            "",
            "Press ESC to return"
        };
        for (size_t i = 0; i < h.size(); ++i) {
            sf::Text t(font, h[i], 36);
            t.setFillColor(sf::Color::White);
            t.setPosition({ 120, float(70 + 50 * i) });
            lines.push_back(t);
        }
    }
    void run(sf::RenderWindow& window) {
        while (window.isOpen()) {
            window.clear(sf::Color(0, 0, 30));
            for (auto& t : lines) window.draw(t);
            window.display();
            while (const auto event = window.pollEvent()) {
                if (event->is<sf::Event::Closed>()) window.close();
                if (event->is<sf::Event::KeyPressed>()) {
                    auto key = event->getIf<sf::Event::KeyPressed>()->scancode;
                    if (key == sf::Keyboard::Scancode::Escape) return;
                }
            }
        }
    }
};



// --------------- 主游戏界面 ---------------
class GameScene {
    static constexpr unsigned int WIDTH = 800, HEIGHT = 600;
    static constexpr float PADDLE_WIDTH = 100, PADDLE_HEIGHT = 20, PADDLE_SPEED = 8;
    static constexpr float BALL_RADIUS = 10, BALL_SPEED = 6;
    static constexpr int BRICK_COLS = 10, BRICK_ROWS = 5;
    static constexpr float BRICK_WIDTH = 75, BRICK_HEIGHT = 25, BRICK_GAP = 5;

    sf::RectangleShape paddle;
    sf::CircleShape ball;
    sf::Vector2f ballVelocity;
    std::vector<sf::RectangleShape> bricks;
    std::vector<bool> bricksAlive;
    bool isPlaying;
    sf::Text infoText;
    SoundManager& sound;
public:
    GameScene(SoundManager& sm)
        : paddle({ PADDLE_WIDTH, PADDLE_HEIGHT }),
        ball(BALL_RADIUS),
        isPlaying(true),
        infoText(ResourceManager::getInstance().font, "", 50),
        sound(sm)
    {
        // paddle
        paddle.setTexture(&ResourceManager::getInstance().texture);
        paddle.setPosition({ (WIDTH - PADDLE_WIDTH) / 2, HEIGHT - PADDLE_HEIGHT - 20 });
        // ball
        ball.setTexture(&ResourceManager::getInstance().texture);
        ball.setOrigin({ BALL_RADIUS, BALL_RADIUS });
        ball.setPosition({ WIDTH / 2, HEIGHT / 2 });
        ballVelocity = { BALL_SPEED, -BALL_SPEED };
        // bricks
        bricks.clear();
        bricksAlive.clear();
        for (int i = 0; i < BRICK_ROWS; ++i) {
            for (int j = 0; j < BRICK_COLS; ++j) {
                sf::RectangleShape brick({ BRICK_WIDTH, BRICK_HEIGHT });
                brick.setTexture(&ResourceManager::getInstance().texture);
                float x = j * (BRICK_WIDTH + BRICK_GAP) + (WIDTH - (BRICK_COLS * (BRICK_WIDTH + BRICK_GAP) - BRICK_GAP)) / 2.0f;
                float y = i * (BRICK_HEIGHT + BRICK_GAP) + 50.0f;
                brick.setPosition({ x, y });
                bricks.push_back(brick);
                bricksAlive.push_back(true);
            }
        }
        infoText.setFillColor(sf::Color::White);
    }

    void reset() {
        paddle.setPosition({ (WIDTH - PADDLE_WIDTH) / 2, HEIGHT - PADDLE_HEIGHT - 20 });
        ball.setPosition({ WIDTH / 2, HEIGHT / 2 });
        ballVelocity = { BALL_SPEED, -BALL_SPEED };
        for (size_t i = 0; i < bricksAlive.size(); ++i) bricksAlive[i] = true;
        isPlaying = true;
        infoText.setString("");
    }
    void render(sf::RenderWindow& window) {
        window.clear(sf::Color::Black);
        window.draw(paddle);
        window.draw(ball);
        for (size_t i = 0; i < bricks.size(); ++i)
            if (bricksAlive[i]) window.draw(bricks[i]);
        if (!isPlaying) {
            // 居中
            sf::FloatRect textRect = infoText.getLocalBounds();
            infoText.setOrigin({ textRect.position.x + textRect.size.x / 2,
                                 textRect.position.y + textRect.size.y / 2 });
            infoText.setPosition({ WIDTH / 2.0f, HEIGHT / 2.0f });
            window.draw(infoText);
        }
        window.display();
    }

    bool handleEvent(const sf::Event& event, sf::RenderWindow& window) {
        if (event.is<sf::Event::Closed>()) window.close();
        if (event.is<sf::Event::KeyPressed>()) {
            auto key = event.getIf<sf::Event::KeyPressed>()->scancode;
            using K = sf::Keyboard::Scancode;
            if (key == K::Escape) return false;
            if (key == K::S) save("assets/save/slot.sav");
            if (key == K::L) load("assets/save/slot.sav");
            if (key == K::M) { sound.setMusic(!sound.isMusicOn()); if (sound.isMusicOn()) sound.playMusic(); else sound.stopMusic(); }
            if (key == K::N) sound.setSound(!sound.isSoundOn());
        }
        return true;
    }

    // 游戏每帧主循环，如果游戏结束返回false，菜单ESC返回false
    bool updateAndInput(sf::RenderWindow& window) {
        if (!window.isOpen()) return false;
        while (const auto event = window.pollEvent()) {
            if (!handleEvent(*event, window)) return false;
        }
        if (isPlaying) {
            // 移动
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Left) && paddle.getPosition().x > 0)
                paddle.move({ -PADDLE_SPEED, 0 });
            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::Right) && paddle.getPosition().x + PADDLE_WIDTH < WIDTH)
                paddle.move({ PADDLE_SPEED, 0 });
            ball.move(ballVelocity);
            // 墙壁
            if (ball.getPosition().x - BALL_RADIUS < 0 || ball.getPosition().x + BALL_RADIUS > WIDTH)
            {
                ballVelocity.x = -ballVelocity.x; sound.playEffect();
            }
            if (ball.getPosition().y - BALL_RADIUS < 0)
            {
                ballVelocity.y = -ballVelocity.y; sound.playEffect();
            }
            // 死亡
            if (ball.getPosition().y + BALL_RADIUS > HEIGHT) {
                infoText.setString("Game Over!");
                isPlaying = false; sound.playEffect();
            }
            // 挡板反弹
            if (ball.getGlobalBounds().findIntersection(paddle.getGlobalBounds())) {
                ballVelocity.y = -std::abs(ballVelocity.y);
                ball.setPosition({ ball.getPosition().x, paddle.getPosition().y - BALL_RADIUS - 1 });
                sound.playEffect();
            }
            // 砖块
            for (size_t i = 0; i < bricks.size(); ++i) {
                if (!bricksAlive[i]) continue;
                if (ball.getGlobalBounds().findIntersection(bricks[i].getGlobalBounds())) {
                    bricksAlive[i] = false;
                    ballVelocity.y = -ballVelocity.y;
                    sound.playEffect();
                    break;
                }
            }
            // 胜利
            bool empty = true;
            for (bool v : bricksAlive) if (v) empty = false;
            if (empty) {
                infoText.setString("You Win!");
                isPlaying = false;
                sound.playEffect();
            }
        }
        render(window);
        return true;
    }

    void save(const std::string& path) {
        SaveData d;
        d.paddleX = paddle.getPosition().x;
        d.ballX = ball.getPosition().x;
        d.ballY = ball.getPosition().y;
        d.ballVelX = ballVelocity.x;
        d.ballVelY = ballVelocity.y;
        d.bricksAlive.resize(bricksAlive.size());
        for (size_t i = 0; i < bricksAlive.size(); ++i) d.bricksAlive[i] = bricksAlive[i];
        d.save(path);
    }

    void load(const std::string& path) {
        SaveData d;
        if (!d.load(path)) return;
        paddle.setPosition({ d.paddleX, HEIGHT - PADDLE_HEIGHT - 20 });
        ball.setPosition({ d.ballX, d.ballY });
        ballVelocity = { d.ballVelX, d.ballVelY };
        for (size_t i = 0; i < bricksAlive.size() && i < d.bricksAlive.size(); ++i)
            bricksAlive[i] = d.bricksAlive[i];
        isPlaying = true;
        infoText.setString("");
    }
};


// ---------------------- 主流程 ----------------------
int main() {
    sf::RenderWindow window(sf::VideoMode({ 800,600 }), "Breakout3.0 (OOP/SFML3)");
    window.setFramerateLimit(60);
    try { ResourceManager::getInstance(); }
    catch (...) { return -1; }
    SoundManager sound;

    SplashScene splash;
    MenuScene menu;
    HelpScene help;

    while (window.isOpen()) {
        splash.run(window, sound);
        // 主菜单进入循环
        while (window.isOpen()) {
            int sel = menu.run(window, sound);
            if (sel == 0) { // 开始
                GameScene game(sound);
                sound.playMusic();
                while (window.isOpen() && game.updateAndInput(window));
            }
            else if (sel == 1) { // 帮助
                help.run(window);
            }
            else if (sel == 2) { // 退出
                window.close();
                break;
            }
        }
    }
    return 0;
}
